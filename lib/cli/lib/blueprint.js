/**
 * @module denali
 * @submodule cli
 */
const path = require('path');
const fs = require('fs');
const chalk = require('chalk');
const dive = require('dive');
const mkdirp = require('mkdirp');
const trash = require('trash');
const ui = require('./ui');
const isDir = require('../../utils/is-dir');
const DenaliObject = require('../../runtime/object');
const template = require('lodash/template');

const blueprintsDir = path.join(__dirname, '..', 'blueprints');

/**
 * The Blueprint class manages generating code from a template, or "blueprint".
 * Blueprints have three main components:
 *
 *   * `Blueprint.locals()` - used to generate data to fill in the the templates
 *   * Templates, found under `<blueprint dir>/files`. These files are copied
 *     over into the project. The can contain ERB style interpolation to inject
 *     values from the `locals` data. Filenames can also contain variables,
 *     delimited by `__variable__`
 *   * `Blueprint.postInstall()`, which runs after the copying operation is
 *     finished. This gives the blueprint a chance to perform additional steps
 *     that simple templating can't support (i.e. install an node module).
 *
 * The code generated by a blueprint can also be removed via the `destroy`
 * command. That command will only remove files that exactly match the
 * what the blueprint generates, so if you modify a file after it was generated,
 * it won't be removed.
 *
 * @class Blueprint
 * @constructor
 * @private
 */
module.exports = DenaliObject.extend({

  /**
   * Description of what the blueprint does. Displayed when `denali generate`
   * is run without arguments.
   *
   * @property description
   * @type String
   */
  description: null,

  /**
   * A hook to generate data to be interpolated into the blueprint's template
   * files.
   *
   * @method locals
   * @return {Object} The data to use during templating
   */
  locals() {
    return {};
  },

  /**
   * Runs after the templating step is complete, letting you make additional
   * modifications (i.e. install a node module).
   *
   * @method postInstall
   */
  postInstall() {},

  /**
   * Runs when `denali destroy` is invoked, after the applicable template files
   * have been removed. You should clean up / reverse any changes made in
   * postInstall(), but only in a way that avoids removing user modifications.
   *
   * @method postUninstall
   */
  postUninstall() {},

  /**
   * Returns the path to this blueprints template files directory. Defaults to
   * `files/`.
   *
   * @method templateFiles
   * @return {String}
   */
  templateFiles() {
    return path.join(blueprintsDir, this.name, 'files');
  },

  /**
   * Generate the blueprint. Generates the data to interpolate into the
   * templates, then copies the template files over into the project. Finally,
   * runs the postInstall hook.
   *
   * @method generate
   * @param {Object} args  the arguments to supply to the `locals()` method
   * @private
   */
  generate(args) {
    const data = this.locals(args);
    const dest = process.cwd();

    dive(this.templateFiles(), { all: true }, (err, absolutepath) => {
      if (err) {
        return ui.error('Error generating blueprint:', err.stack || err);
      }
      if (isDir(absolutepath)) { return null; }
      const relativepath = path.relative(this.templateFiles(), absolutepath);

      const filenameTemplate = template(relativepath, { interpolate: /__([\S]+)__/g });
      const destRelativepath = filenameTemplate(data);
      const destAbsolutepath = path.join(dest, destRelativepath);

      if (fs.existsSync(destAbsolutepath)) {
        return ui.info(`   ${ chalk.green('already exists') } ${ destRelativepath }`);
      }

      const contents = fs.readFileSync(absolutepath, 'utf-8');
      const contentsTemplate = template(contents);
      mkdirp.sync(path.dirname(destAbsolutepath));
      fs.writeFileSync(destAbsolutepath, contentsTemplate(data));
      ui.info(`  ${ chalk.green('create') } ${ destRelativepath }`);
    });

    this.postInstall();
  },

  /**
   * Destroy the blueprint. Generates the data to interpolate into the
   * templates, then deletes any unmodified files that were generated by this
   * blueprint. Then runs the postUninstall hook.
   *
   * @method destroy
   * @param {Object} args  the arguments to supply to the `locals()` method
   * @private
   */
  destroy(args) {
    const data = this.locals(args);
    const dest = process.cwd();

    let filesToDelete = [];
    dive(this.templateFiles(), { all: true }, (err, absolutepath) => {
      return filesToDelete.push(absolutepath);
    });

    // Get the absolute paths for the template source file and the dest file
    filesToDelete = filesToDelete.map((absolutepath) => {
      const relativepath = path.relative(this.templateFiles(), absolutepath);
      const filenameTemplate = template(relativepath, { interpolate: /__([\S]+)__/g });
      const destRelativepath = filenameTemplate(data);
      const destAbsolutepath = path.join(dest, destRelativepath);
      return { destAbsolutepath, destRelativepath, absolutepath };

    // Ensure that the dest file actually exists
    }).filter(({ destAbsolutepath, destRelativepath, absolutepath }) => {
      if (isDir(absolutepath)) { return false; }
      const fileExists = fs.existsSync(destAbsolutepath);
      if (!fileExists) {
        console.log(`  ${ chalk.grey('missing') } ${ destRelativepath }`);
      }
      return fileExists;

    // And either hasn't been altered, or the force option is being used, to
    // ensure we don't destroy code
    }).filter(({ destAbsolutepath, absolutepath, destRelativepath }) => {
      const templateSrc = fs.readFileSync(absolutepath, 'utf-8');
      const compiled = template(templateSrc);
      const destFileIsNotDirty = fs.readFileSync(destAbsolutepath, 'utf-8') === compiled(data);

      if (destFileIsNotDirty) {
        console.log(`  ${ chalk.red('destroy') } ${ destRelativepath }`);
      } else {
        console.log(`  ${ chalk.blue('skipped') } ${ destRelativepath }`);
      }

      return destFileIsNotDirty;
    }).map(({ destAbsolutepath }) => {
      return destAbsolutepath;
    });

    trash(filesToDelete, () => {
      this.postUninstall();
    });
  }

});
