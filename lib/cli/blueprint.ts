import path from 'path';
import fs from 'fs';
import chalk from 'chalk';
import walk from 'walk-sync';
import codeshift from 'jscodeshift';
import mkdirp from 'mkdirp';
import rimraf from 'rimraf';
import ui from './ui';
import isDir from '../utils/is-dir';
import discoverAddons from '../utils/discover-addons';
import {
  template
} from 'lodash';
import DenaliObject from '../metal/object';
import Project from './project';
import { CommandOptions, CommandFlags } from './command';

interface BlueprintsCollection {
  [blueprintName: string]: string;
}

/**
 * The Blueprint class manages generating code from a template, or "blueprint".
 * Blueprints have three main components:
 *
 *   * `Blueprint.locals()` - used to generate data to fill in the the templates
 *   * Templates, found under `<blueprint dir>/files`. These files are copied
 *     over into the project. The can contain ERB style interpolation to inject
 *     values from the `locals` data. Filenames can also contain variables,
 *     delimited by `__variable__`
 *   * `Blueprint.postInstall()`, which runs after the copying operation is
 *     finished. This gives the blueprint a chance to perform additional steps
 *     that simple templating can't support (i.e. install an node module).
 *
 * The code generated by a blueprint can also be removed via the `destroy`
 * command. That command will only remove files that exactly match the
 * what the blueprint generates, so if you modify a file after it was generated,
 * it won't be removed.
 *
 * @module denali
 * @submodule cli
 */
export default class Blueprint extends DenaliObject {

  static findBlueprints(project: Project): BlueprintsCollection {
    let addons = discoverAddons(project.dir);
    // Search every addon plus project app, with precedence given to the app
    let blueprintOrigins = addons.concat([ project.dir ]);
    return blueprintOrigins.reduce((blueprints, originDir) => {
      let addonName = require(path.join(originDir, 'package.json')).name;
      let blueprintDir = path.join(originDir, 'blueprints');
      if (isDir(blueprintDir)) {
        fs.readdirSync(blueprintDir)
        .filter((filepath) => fs.statSync(path.join(blueprintDir, filepath)).isDirectory())
        .forEach((blueprintName) => {
          // Add each blueprint under it's addon namespace, and without the
          // namespace, so that the last addon (or the app) will win in case of
          // collisions.
          blueprints[`${ addonName }:${ blueprintName }`] = path.join(blueprintDir, blueprintName);
          blueprints[blueprintName] = path.join(blueprintDir, blueprintName);
        });
      }
      return blueprints;
    }, {});
  }

  static instanceFor(project: Project, name: string): Blueprint | false {
    let blueprints = this.findBlueprints(project);
    let blueprintDir = blueprints[name];
    if (!blueprintDir) {
      return false;
    }
    let BlueprintClass = require(blueprintDir);
    BlueprintClass = BlueprintClass.default || BlueprintClass;
    return new BlueprintClass(blueprintDir);
  }

  /**
   * Description of what the blueprint does. Displayed when `denali generate`
   * is run without arguments.
   */
  description: string;

  dir: string;

  params: string[] = [];

  flags: CommandFlags = {};

  constructor(dir: string) {
    super();
    this.dir = dir;
  }

  /**
   * A hook to generate data to be interpolated into the blueprint's template
   * files.
   */
  locals(options: CommandOptions): any {
    return {};
  }

  /**
   * Runs after the templating step is complete, letting you make additional
   * modifications (i.e. install a node module).
   */
  async postInstall(options: CommandOptions): Promise<void> {}

  /**
   * Runs when `denali destroy` is invoked, after the applicable template files
   * have been removed. You should clean up / reverse any changes made in
   * postInstall(), but only in a way that avoids removing user modifications.
   */
  async postUninstall(options: CommandOptions): Promise<void> {}

  /**
   * Returns the path to this blueprints template files directory. Defaults to
   * `files/`.
   */
  get templateFiles(): string {
    return path.join(this.dir, 'files');
  }

  /**
   * Generate the blueprint. Generates the data to interpolate into the
   * templates, then copies the template files over into the project. Finally,
   * runs the postInstall hook.
   *
   */
  async generate(options: CommandOptions): Promise<void> {
    let data = this.locals(options);
    let dest = process.cwd();

    walk(this.templateFiles).forEach((relativepath: string) => {
      let absolutepath = path.resolve(path.join(this.templateFiles, relativepath));
      if (isDir(absolutepath)) {
        return null;
      }

      let filenameTemplate = template(relativepath, {
        interpolate: /__([\S]+)__/g,
        sourceURL: relativepath
      });
      let destRelativepath = filenameTemplate(data);
      let destAbsolutepath = path.join(dest, destRelativepath);

      if (fs.existsSync(destAbsolutepath)) {
        return ui.info(`${ chalk.green('already exists') } ${ destRelativepath }`);
      }

      let contents = fs.readFileSync(absolutepath, 'utf-8');
      let contentsTemplate = template(contents, {
        interpolate: /<%=([\s\S]+?)%>/g,
        sourceURL: relativepath
      });
      mkdirp.sync(path.dirname(destAbsolutepath));
      fs.writeFileSync(destAbsolutepath, contentsTemplate(data));
      ui.info(`${ chalk.green('create') } ${ destRelativepath }`);
    });

    await this.postInstall(options);
  }

  /**
   * Destroy the blueprint. Generates the data to interpolate into the
   * templates, then deletes any unmodified files that were generated by this
   * blueprint. Then runs the postUninstall hook.
   */
  async destroy(options: CommandOptions): Promise<void> {
    let data = this.locals(options);
    let dest = process.cwd();

    let filesToDelete: string[] = [];
    walk(this.templateFiles).forEach((relativepath: string) => {
      return filesToDelete.push(path.resolve(path.join(this.templateFiles, relativepath)));
    });

    // Get the absolute paths for the template source file and the dest file
    filesToDelete = filesToDelete.map((absolutepath) => {
      let relativepath = path.relative(this.templateFiles, absolutepath);
      let filenameTemplate = template(relativepath, { interpolate: /__([\S]+)__/g });
      let destRelativepath = filenameTemplate(data);
      let destAbsolutepath = path.join(dest, destRelativepath);
      return { destAbsolutepath, destRelativepath, absolutepath };

    // Ensure that the dest file actually exists
    }).filter(({ destAbsolutepath, destRelativepath, absolutepath }) => {
      if (isDir(absolutepath)) {
        return false;
      }
      let fileExists = fs.existsSync(destAbsolutepath);
      if (!fileExists) {
        ui.info(`${ chalk.grey('missing') } ${ destRelativepath }`);
      }
      return fileExists;

    // And either hasn't been altered, or the force option is being used, to
    // ensure we don't destroy code
    }).filter(({ destAbsolutepath, absolutepath, destRelativepath }) => {
      let templateSrc = fs.readFileSync(absolutepath, 'utf-8');
      let compiled = template(templateSrc);
      let destFileIsNotDirty = fs.readFileSync(destAbsolutepath, 'utf-8') === compiled(data);

      if (destFileIsNotDirty) {
        ui.info(`${ chalk.red('destroy') } ${ destRelativepath }`);
      } else {
        ui.info(`${ chalk.blue('skipped') } ${ destRelativepath }`);
      }

      return destFileIsNotDirty;
    }).map(({ destAbsolutepath }) => {
      return destAbsolutepath;
    });

    filesToDelete.forEach((file) => rimraf.sync(file));
    await this.postUninstall(options);
  }

  addRoute(method: string, urlPattern: string, actionPath?: string, ...args: any[]): void {
    let routesFilepath = path.join(process.cwd(), 'config', 'routes.js');
    let routesSource = fs.readFileSync(routesFilepath, 'utf-8');
    let j = codeshift;
    let ast = codeshift(routesSource);
    let drawRoutesFunction = ast.find(j.ExportDefaultDeclaration).get().value.declaration;
    let routerArgName = drawRoutesFunction.params[0].name;
    let drawRoutesFunctionBody = j(drawRoutesFunction.body);
    let duplicate = drawRoutesFunctionBody.find(j.ExpressionStatement, {
      expression: {
        callee: {
          object: { name: routerArgName },
          property: { name: method }
        },
        arguments: [ urlPattern, actionPath ].concat(args).map((arg) => {
          return { value: arg };
        })
      }
    });
    if (duplicate.length > 0) {
      return;
    }
    let routerInvocations = drawRoutesFunctionBody.find(j.ExpressionStatement, {
      expression: {
        callee: {
          object: { name: routerArgName }
        }
      }
    });
    let lastRouterInvocation = routerInvocations.at(routerInvocations.length - 1);
    let routerMethodExpression = j.memberExpression(j.identifier(routerArgName), j.identifier(method));
    let routerArguments = args.map((arg) => j.stringLiteral(arg));
    let routerMethodInvocation = j.callExpression(routerMethodExpression, routerArguments);
    let newRoute = j.expressionStatement(routerMethodInvocation);
    lastRouterInvocation.insertAfter(newRoute);
    fs.writeFileSync(routesFilepath, ast.toSource({ quote: 'single' }));
  }

  removeRoute(method: string, urlPattern: string, actionPath?: string, ...args: any[]): void {
    let routesFilepath = path.join(process.cwd(), 'config', 'routes.js');
    let routesSource = fs.readFileSync(routesFilepath, 'utf-8');
    let j = codeshift;
    let ast = codeshift(routesSource);
    let drawRoutesFunction = ast.find(j.ExportDefaultDeclaration).get().value.declaration;
    let routerArgName = drawRoutesFunction.params[0].name;
    let drawRoutesFunctionBody = j(drawRoutesFunction.body);
    drawRoutesFunctionBody.find(j.ExpressionStatement, {
      expression: {
        callee: {
          object: { name: routerArgName },
          property: { name: method }
        },
        arguments: [ urlPattern, actionPath ].concat(args).map((arg) => {
          return { value: arg };
        })
      }
    }).remove();
    fs.writeFileSync(routesFilepath, ast.toSource());
  }

}
